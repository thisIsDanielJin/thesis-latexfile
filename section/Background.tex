\chapter{Background}
To understand the choices we're making for the internet today, we have to look back at a long-standing problem: we've run out of the original internet addresses (IPv4). This has forced us into a decades-long transition to a new system (IPv6), where parts of the internet will use only the new addresses. The core challenge is well-known: the old and new systems don't speak the same language, yet both have to work together on a global scale. At the same time, we’re trying to balance running out of old addresses, increasing costs, and the constant risk of things breaking\cite{7737362,LEVIN20141059}.

\section{IPv4 exhaustion and transition to IPv6}
Internet use has expanded to critical infrastructure across consumer, enterprise, and public sectors. Services running at any time of the day and the increase of connected devices have driven steady growth in traffic and endpoints, making address management a central concern\cite{7737362,LEVIN20141059}. IP addresses perform two fundamental roles: identifying endpoints and enabling packet delivery across networks, and uniqueness at global scale is essential\cite{LEVIN20141059}.

IPv4, standardized in 1981-1983, provides a 32-bit address space of roughly 4.3 billion addresses\cite{rfc791}.In practice, not all addresses are usable on the public Internet due to special-use and private allocations, and early design choices further reduced the effectively usable pool\cite{rfc1918,7737362,LEVIN20141059}. Management techniques such as CIDR and NAT slowed the pace of consumption but could not eliminate the finite limit\cite{7737362}.

Exhaustion means that the pool of unused IPv4 addresses has run out, not that IPv4 connections themselves have stopped working. The process started at the global level and then moved downward: IANA allocated its final IPv4 blocks on 3 February 2011, after that, each Regional Internet Registry (RIR) moved into its final phase: APNIC in April 2011, RIPE NCC in September 2012, LACNIC in June 2014 while AFRINIC held on the longest\cite{LEVIN20141059}. A global policy passed on 6 May 2012 established mechanisms for the recovery and redistribution of returned IPv4 address space, yet scarcity has continued to persist\cite{7737362}. The impact has been uneven across regions because historical allocations left some operators with far fewer addresses per user than others\cite{LEVIN20141059}.

The shortage was unavoidable because demand kept rising: by 2014, about 2.9 billion people were online, with more than 200 million new users joining each year after 2010. Internet use jumped from less than 1% of the world’s population in 1994 to over 40% by 2014, and surpassing 4 billion by 2020 and 5.5 billion in 2024 \cite{7737362, itu_d_statistics}. In short, exponential demand confronted a finite IPv4 pool.

IPv6 was standardized in 1995 as the long-term successor, expanding addressing to 128 bits—on the order of $3.4 \times 10^{38}$ unique addresses—and introducing protocol-level improvements aimed at routing scalability, mobility support, and operational security\cite{rfc1883,7737362,LEVIN20141059}. The allocation data highlights how abundant IPv6 is compared to IPv4, even when large IPv6 distributions are considered\cite{7737362}. However, IPv4 and IPv6 don't work together on their own, so bridging mechanisms are needed while both remain in use\cite{LEVIN20141059}.

Even though the technical benefits of IPv6 were clear, its adoption lagged behind the urgency created by IPv4 shortages. IPv6 allocations reported by the RIRs lagged behind user growth, with especially low adoption in some regions, like Africa. At the same time, user-side measurements, such as those from Google, showed less than 10% IPv6 usage, though the trend was gradually increasing \cite{7737362}. Operators had to cover costs for enabling IPv6, including new equipment and configuration, which extended the period of running both protocols, often well beyond 2020 and in some networks possibly past 2030 \cite{7737362}.

Operators and policymakers have followed three main approaches: making better use of IPv4, allocating the remaining IPv4 space more efficiently and transitioning to IPv6\cite{LEVIN20141059}. On the technical side, NAT, especially carrier-grade NAT, conserves public IPv4 addresses by multiplexing many private hosts behind a smaller set of public addresses\cite{rfc2663}. By around 2014, a measurable fraction of users were estimated to traverse CGN\cite{livadariu2018inferring}. While NAT is effective at saving IP addresses, it can make end-to-end connectivity more complicated and add to operational complexity\cite{rfc2993}. Dual stack (running IPv4 and IPv6 in parallel) is broadly available and will remain common for years, but it does not address the decline of IPv4\cite{LEVIN20141059}. Policy measures like smaller allocations and efforts to reclaim unused addresses have helped ease IP address scarcity somewhat, but they don't eliminate the need for IPv6\cite{LEVIN20141059}.

Strategically this means that IPv4 and IPv6 will continue to coexist for a long time, connected through integration methods\cite{7737362,LEVIN20141059}. This situation drives the focus of this thesis: as network operators decide whether to keep dual-stack setups or move to IPv6-only access with translation technologies (like NAT64/DNS64, often paired with CLAT on the client side), it's important to understand the performance trade-offs involved. The next section takes a look at the main transition mechanisms that form the basis of this comparison\cite{7737362,LEVIN20141059}.

\section{IPv6 transition mechanisms}
According to the IETF’s classification of transition strategies, there are three main approaches: dual stack, tunneling, and translation\cite{rfc2893}. Because this thesis focuses on comparing dual stack and translation, tunneling will not be covered. 

\paragraph{Dual-Stack Architecture} 

Dual stack allows networks and hosts to gradually migrate, letting IPv4 and IPv6 run side by side\cite{punithavathani2009ipv4}. In this model, a node runs two IP protocol stacks side by side: one for IPv4 and one for IPv6. This applies to both end systems, clients and servers, and to intermediate devices such as routers and gateways, which can natively handle and forward both IPv4 and IPv6 traffic when they support dual stack \cite{punithavathani2009ipv4}.

Applications written for IPv4 use the IPv4 stack, and IPv6‑capable applications use the IPv6 stack. When sending a packet, the destination address decides which stack to use\cite{rfc4213}. In practice, this works through DNS: A records point to IPv4 addresses, while AAAA records point to IPv6 addresses. The host’s resolver and socket APIs then automatically choose the appropriate protocol stack\cite{punithavathani2009ipv4}.

From a deployment standpoint, dual stack is practical because most modern operating systems come with mature support for both IPv4 and IPv6\cite{rfc7381}. The wide support for both protocols, combined with the fact that most applications run over their native IP without any modifications, helps explain why dual-stack has become the approach for running IPv4 and IPv6 together in real-world networks\cite{punithavathani2009ipv4}. Its main goal is to ensure compatibility and enable a gradual transition: dual-stack lets operators roll out IPv6 while staying connected to the still-dominant IPv4 Internet, but it isn’t meant to solve the issue of address shortages on its own \cite{LEVIN20141059}.

Dual stack also has clear limits. It only allows direct communication between the same protocol: IPv6 to IPv6 and IPv4 to IPv4, so it doesn't bridge the two by itself. When communication across the protocols is needed during the transition, extra mechanisms like tunneling or translation have to be used\cite{punithavathani2009ipv4}. Moreover, dual-stack doesn’t actually save IPv4 addresses. Seeing it as a way to conserve them is misleading, if anything, it maintains high demand for IPv4, since every dual-stacked device still requires IPv4 connectivity\cite{rfc4241} . Global IPv4 exhaustion has continued even with widespread dual-stack deployments, highlighting that dual-stack alone cannot solve the shortage \cite{LEVIN20141059}.

Within this thesis, dual stack serves as the performance and behavior baseline when no translation is involved. As a result, any differences we observe compared to NAT64 with CLAT can be seen as the extra cost of using translation-based approaches. At the same time, dual stack can’t reduce reliance on IPv4 without additional tools, which is why the translation-based mechanisms in the next section are important \cite{punithavathani2009ipv4,LEVIN20141059}.

\paragraph{NAT64/DNS64 Principles} 


NAT64 with DNS64 has emerged as a practical response to the limits of dual stack in the current Internet\cite{rfc7269}. Although dual stack was initially seen as the main strategy for transitioning to IPv6, the ongoing shortage of IPv4 addresses and the uneven adoption of IPv6 make it increasingly difficult to keep every endpoint and network fully dual-stacked\cite{rfc7269}. Translation technologies help bridge the gap, letting IPv6-only devices talk to IPv4-only systems without needing upgrades on every device or huge pools of public IPv4 addresses. In many networks NAT64 and DNS64 can either support or even take the place of dual stack, especially when IPv4 addresses are scarce or updating software everywhere isn’t practical\cite{6231295}.

NAT64 was designed as the next step in the evolution of IP translation technologies. Earlier approaches like Stateless IP/ICMP Translation (SIIT) handled translation on a per-packet basis but needed a strict one-to-one mapping between IPv4 and IPv6 addresses, which limited scalability and flexibility\cite{rfc6146}. NAT64 and DNS64 were created to overcome these limitations, offering clearer design, well-defined behavior, and explicit support for DNSSEC, while keeping the effective header translation techniques from SIIT\cite{6231295}.

Stateful NAT64 enables two-way translation between IPv6 and IPv4, allowing IPv6-only clients to connect to IPv4-only servers using TCP, UDP, or ICMP. It's designed for the long transition period where new networks and devices are primarily IPv6, while many services are still IPv4-only. When used with DNS64, neither the IPv6 client nor the IPv4 server needs any changes to communicate across the translator. Typically, a NAT64 device sits at the boundary between an IPv6-only network and the IPv4 Internet, with one interface facing each side. Packets from an IPv6 host going to an IPv4 server are routed to the NAT64, translated into IPv4, and sent onward. Replies from the server are translated back into IPv6, using the translation state established for that session\cite{rfc6146}.

In practice, NAT64 works through three main components. First, it translates IP and ICMP headers while making sure transport-layer checksums and communication rules are preserved across the IPv6-to-IPv4 boundary. Second, it uses algorithmic address embedding: an operator-assigned IPv6 prefix (Pref64::/n) is combined with the IPv4 address to create “IPv4-converted” IPv6 addresses that the translator can use. Third, its NAT behavior follows standard practices for TCP, UDP, and ICMP—like consistent endpoint mappings and typical filtering modes—so applications and network traversal techniques continue to work as expected. \cite{rfc6146,6231295}.

Address representation is a key part of how NAT64 works. It uses two address pools: an IPv6 pool, made up of a dedicated IPv6 prefix (Pref64::/n) that embeds IPv4 addresses, and an IPv4 pool—usually a small shared prefix—that represents IPv6 clients on the IPv4 Internet. The IPv6 addresses are formed by combining the Pref64::/n with the 32-bit IPv4 address, adding zeros if the prefix is shorter than 96 bits. The Well-Known Prefix 64:ff9b::/96 provides a globally recognizable format, but operators can also use local prefixes. This Well-Known Prefix is especially useful when DNS64 and NAT64 are managed by different parties, as it separates the resolver from the translator while still ensuring packets reach the NAT64 device correctly. On the IPv4 side, the NAT64 translator usually maintains a small pool of public IPv4 addresses that are shared among many IPv6 clients. To make the most of this limited resource, NAT64 often uses address-and-port translation (A+P), allowing multiple IPv6 flows to share a single IPv4 address by assigning each flow a distinct range of ports\cite{6231295,rfc6146}.

NAT64 is stateful. Every time an IPv6 client starts a new connection to an IPv4 server, the translator creates a binding that links the IPv6 address, port, and protocol to an IPv4 address and port from its pool. Inside the translator, the Binding Information Base keeps track of these mappings, connecting each internal IPv6 transport address to its assigned IPv4 address. These mappings can be reused across different destinations, enabling consistent  endpoint-independent connections. A separate session table keeps track of each individual flow to allow more detailed filtering and maintain per-flow state when needed. Connection lifetimes follow BEHAVE guidelines: UDP bindings typically last a few minutes (around two minutes), while TCP bindings can last hours for established connections. The translator also detects TCP connection closures so it can quickly free up resources. Without an existing state in the translator, only IPv6 clients can start new connections to IPv4 servers. For connections initiated from IPv4 to IPv6, the translator needs recent outbound traffic, explicit static mappings, or support from the application itself. Since NAT64 uses endpoint-independent mapping, standard NAT traversal techniques can still work across the translator\cite{6231295,rfc6146}.

DNS64 complements NAT64 by synthesizing AAAA records from A records. When an IPv6-only client looks up a domain and the server only has an IPv4 (A) record, DNS64 steps in: it queries the A record, embeds the resulting IPv4 address into an IPv6 address using the operator’s Pref64::/n, and returns that synthesized IPv6 address to the client\cite{rfc6147}. DNS64 and NAT64 share no runtime state, they only need to agree on the Pref64::/n, using the Well-Known Prefix by default or a specific local prefix\cite{6231295}. 

An end-to-end flow is therefore: an IPv6-only client receives a synthesized AAAA embedding the server’s IPv4 address, sends IPv6 packets to that address (routed to the NAT64), the translator allocates or looks up the binding, translates headers, and forwards to the IPv4 server. Return traffic is reverse-translated using the session and Binding Information Base state until idle timers expire or TCP teardown is observed \cite{6231295,rfc6147}.

Choosing between the Well-Known Prefix and a local prefix can affect how well networks work together when DNS64 and NAT64 are run by different organizations, but it doesn't significantly impact the cost of translating individual packets\cite{6231295}. From a deployment standpoint, setting up NAT64 with DNS64 at the network edge is relatively simple. It lets operators run IPv6-only access networks while still reaching IPv4-only services. This is different from running a full dual-stack network, where both IPv4 and IPv6 are enabled throughout. The main trade-offs of NAT64 with DNS64 are that session initiation tends to favor IPv6 to IPv4 connections, it relies on DNS64 for translating names, and some protocols aren’t fully supported. In return, it allows for much more efficient sharing of IPv4 addresses\cite{rfc6146}.

From both an operational and cost perspective, NAT64/DNS64 allows operators to run IPv6-only networks at the edge, with IPv4 needed only at the gateway. This makes managing IPv4 addresses easier and avoids the complexity of running dual-stack everywhere. According to a 2024 study, large-scale measurements show that public deployment in DNS resolvers is still quite limited. Among public IPv4 resolvers, only about 0.1% (1,873 out of 1.9 million) deploy NAT64, while among public IPv6 resolvers, the number is around 0.04% (110 out of 279,100)\cite{10.1007/978-3-031-56249-5_5}. Most DNS64 resolvers return IPv6 addresses within the designated NAT64 special-use prefix, though some use alternative private ranges or publicly routable IPv6 addresses. When public addresses are used, the NAT64 gateway is often in a different Autonomous System than the resolver and is typically run by a network service provider rather than the same organization. In many cases, the device handling IPv4 NAT also serves as the NAT64 gateway, showing that NAT64 is often integrated into existing infrastructure. Deployment tends to be geographically concentrated, with about half of all observed cases occurring within the top five Autonomous Systems for both IPv4 and IPv6 resolvers. Legitimate deployments are particularly common in China, across mobile networks, service providers, and academic networks. While most setups follow the relevant specifications correctly, some misconfigurations have been seen that could affect reachability\cite{10.1007/978-3-031-56249-5_5}.

Finally, NAT64/DNS64 forms the foundation of 464XLAT. In this setup, a client-side stateless translator (CLAT) handles local IPv4-only applications, while the provider's NAT64 performs the stateful IPv6-to-IPv4 translation. Both use the same Pref64::/n and DNS64 principles. This approach makes legacy applications work more seamlessly on IPv6-only networks, as discussed in the next section\cite{6231295}.

\paragraph{Client-Side Translation: The role of CLAT and 464XLAT} 


Building on the NAT64/DNS64 principles, 464XLAT is a practical method to provide limited IPv4 connectivity across IPv6-only access networks without tunnels, keeping the network IPv6-first while allowing legacy IPv4-only applications to function. It is not a full IPv4 replacement: it supports outbound, client-to-server IPv4 use cases toward globally reachable IPv4 servers, does not provide inbound IPv4 reachability, and is not aimed at IPv4 peer-to-peer scenarios. The goal is to restore just enough IPv4 to keep legacy software usable while keeping native and modern traffic on IPv6 wherever possible \cite{rfc6877}.

The architecture defines two roles and introduces no new control protocols. On the customer side, the CLAT (Customer-side Translator) performs stateless IPv4/IPv6 translation (SIIT) as specified in the existing translation RFCs. It can run on a router in fixed access or directly on an end host (e.g., a smartphone) in mobile networks. Even when it runs on an end device, the CLAT forwards traffic between a private IPv4 interface for local applications and the IPv6 uplink. In many home or office setups, the CLAT also handles basic LAN services like DHCP for private IPv4 addresses and a DNS proxy. On the provider side, the PLAT (Provider-side Translator) is a stateful NAT64 that allows many IPv6-only clients to share a pool of IPv4 addresses. Together, CLAT and PLAT build on existing SIIT and NAT64 technologies—no new protocols are needed\cite{rfc6877}.

464XLAT can operate with or without DNS64. It doesn’t need synthesized AAAA records: an IPv4-only application can open IPv4 sockets or use IPv4 addresses directly, and the CLAT will translate those packets into IPv6 and send them to the PLAT, which then translates them back to IPv4. When DNS64 is used, name-based connections to IPv4-only destinations go through a single stateful translation at the PLAT. This avoids having both a stateless step at the CLAT and a stateful step at the PLAT, reducing per-connection processing and keeping the translation state centralized at the provider\cite{rfc6877}.

The resulting packet flows are straightforward. If the destination supports IPv6, traffic goes directly over IPv6 with no translation. If the destination is IPv4-only and DNS64 is used, the client receives a synthesized AAAA record, sends IPv6 packets, and the PLAT performs a single NAT64 translation. For applications that use IPv4 addresses directly or only support IPv4 sockets, the CLAT first translates the private IPv4 packets to IPv6 in a stateless manner, and the PLAT then applies stateful NAT64. This two-step translation ensures compatibility with applications that rely on hardcoded IPv4 addresses. \cite{rfc6877}.

This model works for both fixed and mobile networks. In wired networks, the CPE (customer premises equipment) acts as the CLAT: devices on the LAN keep using private IPv4, the CPE routes native IPv6 traffic, and it applies SIIT toward the PLAT for IPv4-only traffic. In 3GPP mobile networks, the user equipment usually runs the CLAT: it provides a private IPv4 stack for local apps, translates IPv4-only traffic into IPv6 for the PLAT, and sends IPv6-native traffic directly without involving the CLAT. When tethering, the user equipment can create a small private IPv4 LAN behind it (using NAT44) and still perform stateless translation before sending traffic over the IPv6 connection, staying compatible with mobile policies\cite{rfc6877}.

From an operational perspective, 464XLAT has several advantages. By keeping IPv4 state centralized in the PLAT, providers can efficiently share limited IPv4 resources among many subscribers. Deployments are also faster to roll out, since the access network can stay IPv6-only and existing standards are reused. Running an IPv6-only access network can be simpler than maintaining dual-stack, it involves fewer protocols to manage and troubleshoot. Native IPv6 traffic stays end-to-end, and translation only happens for IPv4 flows. The PLAT can even be provided by a third party, letting an access provider run an IPv6-only network while sending CLAT-translated traffic to an external NAT64 service. This approach works especially well in mobile networks, where maintaining separate PDP contexts for IPv4 and IPv6 adds complexity\cite{rfc6877}.

Some practical considerations apply. CLAT uses standard IPv4-embedded IPv6 formats. It usually reserves separate /64 blocks for the uplink, each downlink segment, and stateless translation traffic. If a dedicated translation prefix isn’t provided, the CLAT can combine LAN addresses to a single IPv4 address and map that to an IPv6 address it controls. The CLAT also needs to know the PLAT’s translation prefix, which can be discovered automatically or set manually. By design, the prefixes for CLAT and PLAT translations are kept separate\cite{rfc6877}.


\section{Linux implementations of CLAT}

\paragraph{Tayga} 



Tayga is a free, stateless NAT64 implementation for Linux, positioned as a lightweight, production‑quality translator for environments where deploying a dedicated hardware or full‑blown software NAT64 device would be excessive\cite{Repas_Farnadi_Lencse_2014}. At the time of the cited study, the latest release referenced was $0.9.2$, which the authors evaluate as representative for open‑source NAT64 on Linux\cite{palrd_tayga_readme}.

Its design philosophy is to perform transparent IPv6–to–IPv4 address and header translation while explicitly leaving policy enforcement and state handling to the Linux packet filtering and NAT framework (iptables)\cite{Repas_Farnadi_Lencse_2014}. The authors stress that Tayga does not aim to replicate the flexibility of Linux’s packet filters; instead, it is built to integrate cleanly with them, keeping the translator itself simple and predictable \cite{Repas_Farnadi_Lencse_2014}.

Functionally, Tayga provides one‑to‑one IPv6$\leftrightarrow$IPv4 address mapping (stateless translation) and does not offer many‑to‑one address multiplexing. In a typical deployment, Tayga is paired with DNS64 and a stateful NAT44 configured in iptables \cite{Repas_Farnadi_Lencse_2014}. For an IPv6 client reaching an IPv4 server, Tayga maps the client’s IPv6 source to a private IPv4 from a configured dynamic pool (1:1), and then NAT44 performs SNAT from that private address to the NAT64 gateway’s public IPv4 \cite{Repas_Farnadi_Lencse_2014}. On the return path, NAT44 restores the private IPv4, after which Tayga reconstructs the corresponding IPv6 destination using its 1:1 mapping and forwards the IPv6 packet back to the client \cite{Repas_Farnadi_Lencse_2014}. This design requires provisioning a sufficiently large private IPv4 pool to support concurrent mappings \cite{Repas_Farnadi_Lencse_2014}.

From a deployment perspective, Tayga’s stateless core means there is no built‑in session tracking or policy engine; scalability and IPv4 address conservation depend on the NAT44 stage and the size of the private IPv4 pool, making Tayga a good fit when a simple, transparent translator is needed\cite{Repas_Farnadi_Lencse_2014}. 

\paragraph{Tundra} 


Tundra is an open-source IPv6-to-IPv4 and IPv4-to-IPv6 translator for Linux that runs entirely in user space. It is written in C, implements SIIT\cite{rfc7915}, and is designed to take advantage of multicore CPUs with a multi-threaded architecture. Packet input and output can be handled through the Linux TUN driver or via inherited file descriptors\cite{labuda_tundra_nat64}.

Functionally, Tundra supports several stateless translation modes. In Stateless NAT64 mode it enables a single host to reach IPv4-only destinations and, when combined with NAT66, it can be used to serve multiple IPv6-only hosts behind it \cite{labuda_tundra_nat64}. In Stateless CLAT mode it allows IPv4-only applications on an IPv6-only network with NAT64 to access IPv4-only hosts. Deployed on a router with an IPv6-only uplink and NAT64, it can produce a dual-stack internal network when paired with NAT44 \cite{labuda_tundra_nat64}. Beyond these, a pure SIIT mode translates addresses that embed IPv4 within an IPv6 translation prefix and vice versa \cite{labuda_tundra_nat64}. 

The design focuses on providing a minimal feature set for SIIT/NAT64/CLAT. It avoids unnecessary features and doesn’t allocate any extra memory after initialization. \cite{labuda_tundra_nat64}. The addressing model doesn’t use a dynamic pool, it relies on a single fixed IP from the configuration. This means that on its own, the translator can only serve one host. However, it can scale to multiple hosts or networks when used together with NAT66 or NAT44\cite{labuda_tundra_nat64}.

Compared to similar user-space, stateless translators like Tayga, Tundra offers multi-threading, multiple configurable modes and the option to operate on inherited file descriptors, while it deliberately lacks a dynamic address pool\cite{labuda_tundra_nat64}. 

\paragraph{Jool} 


Jool is another well-known open-source implementation for IPv4/IPv6 translation, specifically designed for Linux systems\cite{jool_introduction}. Unlike Tundra's focus on userspace implementation, Jool operates within the kernel space and provides support for both Stateful NAT64 and SIIT modes. The SIIT functionality, which was introduced starting with version 3.3.0, is particularly relevant for 464XLAT deployments as it enables CLAT-like functionality on Linux systems, while the NAT64 mode can handle the PLAT side of the translation process\cite{jool_introduction}.

From an architectural perspective, Jool offers two distinct integration modes for packet interception: Netfilter mode and iptables mode. Both approaches hook into the PREROUTING chain but differ in their operational characteristics\cite{jool_introduction}. The Netfilter mode, which was the sole operation mode until Jool version 3.5, exhibits what can be described as "greedy" behavior. It intercepts all inbound packets within its network namespace without any matching conditions and attempts to translate everything, only leaving packets untouched when translation fails \cite{jool_introduction}. This mode is limited to at most one Netfilter SIIT instance and one Netfilter NAT64 instance per network namespace and begins translating immediately upon creation.

In contrast, the iptables mode, available since Jool 4.0.0, implements a more selective approach by functioning as an iptables target that can be used within specific rules\cite{jool_introduction}. This mode leverages iptables matching system, meaning only packets that match a particular rule are handed to Jool for processing, while other traffic proceeds normally through the network stack. This design allows for any number of iptables-based Jool instances and rules per namespace, with instances remaining idle until a matching iptables rule directs packets to them \cite{jool_introduction}.

An important characteristic shared by both modes is their handling of successfully translated packets. Rather than following the conventional path through the FORWARD chain, translated packets are sent directly to POSTROUTING, effectively bypassing the FORWARD chain entirely\cite{jool_introduction}.

Jool's packet handling logic follows a systematic approach for determining which packets can be translated. For packets that cannot be translated, Jool returns them to the kernel under various conditions, such as when an iptables rule references a non-existent instance, when translation succeeds but the resulting packet is unroutable, or when the translator is disabled by configuration\cite{jool_introduction}. In SIIT mode, specific untranslatable conditions include scenarios where addresses cannot be translated due to local interface addresses or absence of applicable translation strategies\cite{jool_introduction}.

The fact that Jool supports the essential protocols used in our measurements makes it well-suited for the throughput and RTT evaluations conducted with iperf and ping respectively \cite{jool_introduction}.
